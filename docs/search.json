{
  "articles": [
    {
      "path": "1-O_que_e_R.html",
      "title": "O que é R?",
      "description": "Tipos de Varíaveis e Estrutura de Dados",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 5, 2021",
      "contents": "\n\nContents\nConteúdos\nProfessor\nO que é R?\nTipos de Variáveis do R\nEstruturas de Dados\nO que podemos fazer com vetores e listas?\ndata.frames e tibbles\n\nVetores Especiais – factor\nValores Especiais\npacote::funcao()\nAmbiente\n\n\nBem vindos à disciplina!\n\n\n\nFigure 1: Bem-vindo!\n\n\n\nConteúdos\nVamos usar todo o universo do {tidyverse}!\nAula 1 - O que é R?\nAula 2 e 3 — dplyr e manipulação de dados\nAula 4 e 5 — ggplot2 e visualização de dados\nAula 6 — Programação funcional com purrr e furrr\nAula 7 — Regressão Linear e Regressão Logística\nProfessor\nJosé Eduardo Storopoli (Duda)\nO que é R?\nR vem da linguagem S que é uma linguagem estatística desenvolvida na Bell Labs na década de 1970s. E R é o “filho” opensource do S.\nRmarkdown é uma boa combinação de gráficos, narrativa e código. Veja o exemplo da figura abaixo.\n\n\n\nFigure 2: Exemplo de um Plot em R\n\n\n\nTipos de Variáveis do R\nnumeric\ninteger\ndouble\n\nlogical\ncharacter\n\n\ntypeof(1L)\n\n[1] \"integer\"\n\ntypeof(1.0)\n\n[1] \"double\"\n\ntypeof(TRUE)\n\n[1] \"logical\"\n\ntypeof(\"Oi!\")\n\n[1] \"character\"\n\nis.numeric(1)\n\n[1] TRUE\n\nEstruturas de Dados\nMesmo tipo de variáveis:\n1-D: Vetores c(...)\n2-D: Matrizes matrix()\nN-D: Arrays array()\n\nTipos diferentes de variáveis:\n1-D: Listas list(...)\n2-D: Dataframes data.frame(...) ou tibble(...)\n\n\nOBS: Para designar podemos usar o x = valor, mas usamos o <- pois não permite equivalência ela assinala tudo que está a direita da flecha para a variável à esquerda da flecha. Ex x <- valor (similar ao x := valor). Inclusive alt + - gera um <- com um whitespace ao redor.\n\n\n\nvetor_integer <- c(1L, 7L:9L)\nvetor_integer\n\n[1] 1 7 8 9\n\ntypeof(vetor_integer)\n\n[1] \"integer\"\n\nis.numeric(vetor_integer)\n\n[1] TRUE\n\nvetor_doubles <- c(1, 7:9)\nvetor_doubles\n\n[1] 1 7 8 9\n\ntypeof(vetor_doubles)\n\n[1] \"double\"\n\nis.numeric(vetor_doubles)\n\n[1] TRUE\n\nvetor_logical <- c(TRUE, FALSE)\nvetor_logical\n\n[1]  TRUE FALSE\n\ntypeof(vetor_logical)\n\n[1] \"logical\"\n\nvetor_character <- c(\"Oi!\", \"Tchau!\")\nvetor_character\n\n[1] \"Oi!\"    \"Tchau!\"\n\ntypeof(vetor_character)\n\n[1] \"character\"\n\n\n\nlista_mista <- list(\"Oi!\", TRUE, 1L)\ntypeof(lista_mista)\n\n[1] \"list\"\n\nvetor_coerce <- c(\"Oi!\", TRUE, 1L)\nvetor_coerce\n\n[1] \"Oi!\"  \"TRUE\" \"1\"   \n\ntypeof(vetor_coerce)\n\n[1] \"character\"\n\n\nOBS: Named List\n\n\n\nlista_nomeada <- list(\n  \"character\" = \"Oi!\",\n  \"logical\" = TRUE,\n  \"integer\" = 1L\n)\n\nstr(lista_nomeada)\n\nList of 3\n $ character: chr \"Oi!\"\n $ logical  : logi TRUE\n $ integer  : int 1\n\nO que podemos fazer com vetores e listas?\ndimensões - dim()\ncomprimento - length()\nIndexar:\nlista[1] - retornará sempre uma list\nlista[[1]] - retornará sempre um elemento\nlista$1 atalho para lista[[\"1\"]]\nlista$nome - atalho para lista[[\"nome\"]]\nlista[\"nome\"] - retonará sempre uma list\nlista[[\"nome\"]] - retornará sempre uma list\n\nFatiar:\nlista[1:30]\n\n\n\nstr(lista_nomeada[1])\n\nList of 1\n $ character: chr \"Oi!\"\n\nstr(lista_nomeada[[1]])\n\n chr \"Oi!\"\n\nstr(lista_nomeada$logical)\n\n logi TRUE\n\nstr(lista_nomeada[[\"logical\"]])\n\n logi TRUE\n\nstr(lista_nomeada[\"character\"])\n\nList of 1\n $ character: chr \"Oi!\"\n\nstr(lista_nomeada[1:2])\n\nList of 2\n $ character: chr \"Oi!\"\n $ logical  : logi TRUE\n\ndata.frames e tibbles\n\n\ndf <- data.frame(\n  a = sample(c(\"A\", \"B\"), 100, replace = TRUE),\n  x = runif(100),\n  y = rnorm(100),\n  dia = \"hoje\"\n)\ndf\n\n    a            x            y  dia\n1   A 0.4281593310  0.269978231 hoje\n2   B 0.4868348911  0.095304228 hoje\n3   A 0.0820855715 -0.481754067 hoje\n4   B 0.1115638788 -0.055112687 hoje\n5   B 0.3120309373  0.080680295 hoje\n6   B 0.1559161441 -0.856900615 hoje\n7   B 0.9250782428 -1.219728582 hoje\n8   A 0.5375251151 -0.469061147 hoje\n9   A 0.9710417085  0.105590612 hoje\n10  A 0.1825689489 -0.252633500 hoje\n11  B 0.8158685113  0.987786498 hoje\n12  B 0.8076367218 -1.764724579 hoje\n13  A 0.0215901232  0.147655350 hoje\n14  B 0.9049002680 -0.406698762 hoje\n15  A 0.5065202438 -1.011156177 hoje\n16  B 0.9890767601 -0.881097218 hoje\n17  B 0.9029677201 -0.796301865 hoje\n18  B 0.0389202889  0.446744319 hoje\n19  B 0.2675222848 -1.722809258 hoje\n20  B 0.3385979417 -0.137887757 hoje\n21  A 0.7043328446  0.109971427 hoje\n22  A 0.0812420761  0.342436066 hoje\n23  A 0.5050319710 -0.524781137 hoje\n24  A 0.0055027339 -0.605144386 hoje\n25  A 0.5307187303  0.189756074 hoje\n26  B 0.4540547624  2.695700727 hoje\n27  B 0.3238999210 -1.450719399 hoje\n28  B 0.9441079567  0.685578988 hoje\n29  A 0.1721155988  1.203063446 hoje\n30  A 0.6548470221  1.836115260 hoje\n31  B 0.7591338588 -0.216659942 hoje\n32  A 0.6003661626 -0.107474283 hoje\n33  A 0.8903045510  0.865224557 hoje\n34  A 0.2108174691 -0.399176945 hoje\n35  A 0.3444550368 -0.034249384 hoje\n36  A 0.8269297550  1.027778396 hoje\n37  A 0.6462185415 -0.513229805 hoje\n38  B 0.0557410994  0.242046820 hoje\n39  B 0.4327699824  0.536836541 hoje\n40  A 0.3903368728 -2.780629274 hoje\n41  A 0.9936964933 -0.168371936 hoje\n42  B 0.0942324006  0.142131995 hoje\n43  A 0.2220998409 -1.902909550 hoje\n44  A 0.1657842193 -0.379779597 hoje\n45  B 0.9074458501  0.650023169 hoje\n46  B 0.9209475338  1.294418126 hoje\n47  A 0.3884519869  1.387078425 hoje\n48  B 0.1147099726  1.382555289 hoje\n49  A 0.2213811132 -0.266496800 hoje\n50  B 0.2811411056 -1.390361264 hoje\n51  A 0.1652040214  0.358929156 hoje\n52  B 0.9750492380  0.291513490 hoje\n53  A 0.2308478188 -0.640951317 hoje\n54  B 0.1566889770  0.534241389 hoje\n55  A 0.3575788017  0.191309329 hoje\n56  A 0.1447510323 -1.935419828 hoje\n57  A 0.0179871691  0.289963956 hoje\n58  B 0.2447288262 -0.217574570 hoje\n59  A 0.1486422189 -0.282944621 hoje\n60  B 0.8791642324 -1.378434160 hoje\n61  B 0.4138095400  1.794416366 hoje\n62  A 0.9314968348  0.357231562 hoje\n63  A 0.2441937090  0.852516418 hoje\n64  B 0.4878146139 -0.306324773 hoje\n65  A 0.0416739325 -1.247352661 hoje\n66  A 0.2269596576  0.632282054 hoje\n67  B 0.1859573806 -0.670737727 hoje\n68  B 0.6532306606 -0.918216119 hoje\n69  B 0.9497359416  0.189061862 hoje\n70  B 0.9849440183 -0.006510629 hoje\n71  B 0.6680205881 -0.522710828 hoje\n72  B 0.2329548134  0.372391690 hoje\n73  A 0.2203577948  1.654717620 hoje\n74  B 0.4271905620 -1.573702940 hoje\n75  A 0.3272917927 -1.662817857 hoje\n76  A 0.5446289470  1.169363720 hoje\n77  B 0.5443003636 -0.080021946 hoje\n78  B 0.4866502171 -0.091718992 hoje\n79  B 0.8194582539  0.791315830 hoje\n80  A 0.2731000239  0.011709433 hoje\n81  A 0.9281988938 -2.035127908 hoje\n82  B 0.3261438510  0.997379451 hoje\n83  A 0.0008921006  0.597160581 hoje\n84  A 0.0867166396 -0.855526273 hoje\n85  A 0.1440573074  0.719976744 hoje\n86  B 0.1551962886  2.164480296 hoje\n87  A 0.2705750179  0.706043565 hoje\n88  B 0.3824789040  0.624833036 hoje\n89  B 0.6541009913 -0.306490741 hoje\n90  B 0.5896097419  0.919150593 hoje\n91  B 0.4150985889 -0.245577928 hoje\n92  A 0.6723064925  0.864896557 hoje\n93  B 0.7361554641  2.097069247 hoje\n94  B 0.6913003095 -0.118602748 hoje\n95  A 0.1250859718  0.803666940 hoje\n96  A 0.0204824726 -0.042559470 hoje\n97  B 0.6477508487 -0.832276906 hoje\n98  A 0.5620869414 -0.443712734 hoje\n99  A 0.4697715018 -0.169504831 hoje\n100 B 0.8700048304  1.603792082 hoje\n\nPara solucionar a facilidade de visualização e inspeção de data.frames o {tidyverse} possui uma estrutura de dados chamada tibble:\n\n\nlibrary(tibble)\nconvert_df <- as_tibble(df)\nstr(convert_df)\n\ntibble [100 × 4] (S3: tbl_df/tbl/data.frame)\n $ a  : chr [1:100] \"A\" \"B\" \"A\" \"B\" ...\n $ x  : num [1:100] 0.4282 0.4868 0.0821 0.1116 0.312 ...\n $ y  : num [1:100] 0.27 0.0953 -0.4818 -0.0551 0.0807 ...\n $ dia: chr [1:100] \"hoje\" \"hoje\" \"hoje\" \"hoje\" ...\n\nOutra vantagem do tibble é que eu consigo criar colunas com base em colunas “passadas”. Por exemplo isso dá um erro com a função data.frame:\n\n\ndf_error <- data.frame(\n  a = 1:10,\n  b = a + 1\n)\n\n\nJá no tibble eu consigo!\n\n\ntbl <- tibble(\n  a = 1:10,\n  b = a + 1\n)\ntbl_complexa <- tibble(\n  idade_ano = rnorm(100, mean = 30, sd = 10),\n  altura_cm = rnorm(100, mean = 165, sd = 10),\n  peso_kg = rnorm(100, mean = 70, sd = 10),\n  IMC = peso_kg / (altura_cm ^ 2),\n  glicose = rexp(100, rate = IMC / 10)\n)\ntbl_complexa\n\n# A tibble: 100 × 5\n   idade_ano altura_cm peso_kg     IMC glicose\n       <dbl>     <dbl>   <dbl>   <dbl>   <dbl>\n 1      21.3      155.    66.2 0.00274   5356.\n 2      48.4      173.    70.8 0.00238    447.\n 3      42.1      170.    75.4 0.00262   1201.\n 4      27.7      166.    61.8 0.00225    524.\n 5      25.0      169.    66.6 0.00233   1844.\n 6      42.6      167.    66.5 0.00239   8533.\n 7      23.7      166.    63.1 0.00229   9918.\n 8      31.4      165.    63.9 0.00234    741.\n 9      24.4      152.    66.9 0.00291   3008.\n10      33.8      175.    75.0 0.00244   2575.\n# … with 90 more rows\n\nVetores Especiais – factor\nfactor são fatores, que para “estatísticos” é variáveis qualitativas (veja o caso da ANOVA).\nfactor é especial pq ele no fundo é um vetor de integer sendo que cada integer é uma categoria diferentes.\n\n\nvetor_factor <- factor(c(\"A\", \"B\", \"C\"))\nstr(vetor_factor)\n\n Factor w/ 3 levels \"A\",\"B\",\"C\": 1 2 3\n\ntypeof(vetor_factor)\n\n[1] \"integer\"\n\nclass(vetor_factor)\n\n[1] \"factor\"\n\nunclass(vetor_factor)\n\n[1] 1 2 3\nattr(,\"levels\")\n[1] \"A\" \"B\" \"C\"\n\nValores Especiais\natômicos integer, logical e character: apenas um — NA\natômicos double: quatro — NA, NaN, Inf e -Inf\nvetores:\nNA - logical\nNA_integer_ - integer\nNA_real_ - double\nNA_character_ - character\n\npacote::funcao()\nÀs vezes diferentes funções possuem o mesmo nome. Como que resolvemos esse conflito de namespace.\nSimples! Nós chamamos a função com pacote::funcao()\nExemplo tibble::as_tibble()\nAmbiente\n\n\nsessionInfo()\n\nR version 4.2.2 (2022-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.1 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] tibble_3.1.8\n\nloaded via a namespace (and not attached):\n [1] rstudioapi_0.14 knitr_1.42      magrittr_2.0.3  downlit_0.4.2  \n [5] R6_2.5.1        rlang_1.0.6     fastmap_1.1.0   fansi_1.0.4    \n [9] highr_0.10      tools_4.2.2     xfun_0.37       png_0.1-8      \n[13] utf8_1.2.3      cli_3.6.0       jquerylib_0.1.4 withr_2.5.0    \n[17] htmltools_0.5.4 yaml_2.3.7      digest_0.6.31   lifecycle_1.0.3\n[21] sass_0.4.5      vctrs_0.5.2     distill_1.5     memoise_2.0.1  \n[25] glue_1.6.2      cachem_1.0.6    evaluate_0.20   rmarkdown_2.20 \n[29] compiler_4.2.2  bslib_0.4.2     pillar_1.8.1    jsonlite_1.8.4 \n[33] pkgconfig_2.0.3\n\n\n\n\n",
      "last_modified": "2023-02-27T14:11:11+00:00"
    },
    {
      "path": "2-Manipulacao_Dados.html",
      "title": "Manipulação de Dados",
      "description": "dplyr, readr, tidyr, stringr",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 7, 2021",
      "contents": "\n\nContents\nO que é Tidy Data?\nO pipe %>%\nComo ler dados com o {readr}\ncol_types – O argumento que eu mais uso em read_*()\n\nManipulação de dados com o {dplyr}\nSelecionar Variáveis – dplyr::select()\nManipular Variáveis – dplyr::mutate()\nAgrupar e Sumarizar Variáveis – dplyr::group_by() e dplyr::summarise()\nJoins com dplyr::join*\n\nMais transformações para formato Tidy Data com {tidyr}\nExtras\nConverter verbos {dplyr} em SQL com o {dbplyr}\nBig Data com {arrow}\n\nAmbiente\n\n\n\n\n\nFigure 1: Tidy Data\n\n\n\nO que é Tidy Data?\ncada variável uma coluna\ncada observação uma linha\ncada célula uma mensuração única\nO pipe %>%\nx %>% f(y) vira f(x, y)\nx %>% f(y) %>% f(z) vira f(f(x, y), z)\n\n\nlibrary(magrittr)\n\n# atalho é CTRL + SHIFT + M\n\nc(0:10, NA) %>%\n  mean(na.rm = TRUE) %>% \n  print() %>% \n  message() %>% \n  message()\n\n[1] 5\n\nComo ler dados com o {readr}\nVamos começar com o primeiro passo da análise de dados: a importação dos dados.\nPara isso o {tidyverse} possui um pacote chamado {readr}.\nread_csv(): CSV padrão americano\nread_csv2(): CSV padrão europeu/brasileiro\nread_tsv(): TSV\nread_delim(): Coringa\nNa pasta datasets/ temos diversos datasets interessantes:\nadult.csv\ncountries_of_the_world.csv\ncovid_19_data.csv: versão 147 de 27/02/2021.\nSe vocês quiserem ler arquivos .xlsx ou .xls usem o pacote {readxl}\ncol_types – O argumento que eu mais uso em read_*()\n\n\nlibrary(readr)\nadult <- read_csv(\"datasets/adult.csv\",\n                  col_types = \"_iffifffif\")\n\n\n\n\ncountries <- read_csv(\"datasets/countries_of_the_world.csv\", \n    col_types = cols(Population = col_integer(), \n        `Net migration` = col_double()), \n    locale = locale(decimal_mark = \",\"))\n\n\n\n\ncovid <- read_csv(\"datasets/covid_19_data.csv\", \n    col_types = cols(SNo = col_skip(), ObservationDate = col_date(format = \"%m/%d/%Y\")))\n\n\nManipulação de dados com o {dplyr}\n\n\n\nFigure 2: dplyr\n\n\n\nSelecionar Variáveis – dplyr::select()\n\n\nlibrary(dplyr)\nadult_clean <- adult %>% \n  select(age, workclass, education,\n         education_num = `educational-num`,\n         marital_status = `marital-status`,\n         race, gender,\n         hours_per_week = `hours-per-week`,\n         income)\n\n\n\nOBS: Tem a função rename_with do {dplyr} versão 1.0.\n\n\n\nadult %>% \n  rename_with(~gsub(\"-\", \"_\", .x))\n\n# A tibble: 48,842 × 9\n     age workclass educa…¹ educa…² marit…³ race  gender hours…⁴ income\n   <int> <fct>     <fct>     <int> <fct>   <fct> <fct>    <int> <fct> \n 1    25 Private   11th          7 Never-… Black Male        40 <=50K \n 2    38 Private   HS-grad       9 Marrie… White Male        50 <=50K \n 3    28 Local-gov Assoc-…      12 Marrie… White Male        40 >50K  \n 4    44 Private   Some-c…      10 Marrie… Black Male        40 >50K  \n 5    18 ?         Some-c…      10 Never-… White Female      30 <=50K \n 6    34 Private   10th          6 Never-… White Male        30 <=50K \n 7    29 ?         HS-grad       9 Never-… Black Male        40 <=50K \n 8    63 Self-emp… Prof-s…      15 Marrie… White Male        32 >50K  \n 9    24 Private   Some-c…      10 Never-… White Female      40 <=50K \n10    55 Private   7th-8th       4 Marrie… White Male        10 <=50K \n# … with 48,832 more rows, and abbreviated variable names ¹​education,\n#   ²​educational_num, ³​marital_status, ⁴​hours_per_week\n\n\n\nadult %>% \n  rename_with(~gsub(\"-\", \"_\", .x)) %>% \n  select(where(is.factor)) %>% \n  select(-workclass) %>% \n  rename_all(~paste0(\"antigo_\", .x))\n\n# A tibble: 48,842 × 5\n   antigo_education antigo_marital_status antigo_race antigo…¹ antig…²\n   <fct>            <fct>                 <fct>       <fct>    <fct>  \n 1 11th             Never-married         Black       Male     <=50K  \n 2 HS-grad          Married-civ-spouse    White       Male     <=50K  \n 3 Assoc-acdm       Married-civ-spouse    White       Male     >50K   \n 4 Some-college     Married-civ-spouse    Black       Male     >50K   \n 5 Some-college     Never-married         White       Female   <=50K  \n 6 10th             Never-married         White       Male     <=50K  \n 7 HS-grad          Never-married         Black       Male     <=50K  \n 8 Prof-school      Married-civ-spouse    White       Male     >50K   \n 9 Some-college     Never-married         White       Female   <=50K  \n10 7th-8th          Married-civ-spouse    White       Male     <=50K  \n# … with 48,832 more rows, and abbreviated variable names\n#   ¹​antigo_gender, ²​antigo_income\n\n\nProfessor eu gosto de camelCase e agora?\n\nNão tema, tem o pacote {janitor}\n\n\nlibrary(janitor)\nadult %>% clean_names(case = \"lower_camel\")\n\n# A tibble: 48,842 × 9\n     age workclass educa…¹ educa…² marit…³ race  gender hours…⁴ income\n   <int> <fct>     <fct>     <int> <fct>   <fct> <fct>    <int> <fct> \n 1    25 Private   11th          7 Never-… Black Male        40 <=50K \n 2    38 Private   HS-grad       9 Marrie… White Male        50 <=50K \n 3    28 Local-gov Assoc-…      12 Marrie… White Male        40 >50K  \n 4    44 Private   Some-c…      10 Marrie… Black Male        40 >50K  \n 5    18 ?         Some-c…      10 Never-… White Female      30 <=50K \n 6    34 Private   10th          6 Never-… White Male        30 <=50K \n 7    29 ?         HS-grad       9 Never-… Black Male        40 <=50K \n 8    63 Self-emp… Prof-s…      15 Marrie… White Male        32 >50K  \n 9    24 Private   Some-c…      10 Never-… White Female      40 <=50K \n10    55 Private   7th-8th       4 Marrie… White Male        10 <=50K \n# … with 48,832 more rows, and abbreviated variable names ¹​education,\n#   ²​educationalNum, ³​maritalStatus, ⁴​hoursPerWeek\n\nOrdenar variáveis com dplyr::arrange()\n\n\nadult_clean %>% \n  arrange(-age, education_num) %>% \n  select(age, education_num)\n\n# A tibble: 48,842 × 2\n     age education_num\n   <int>         <int>\n 1    90             2\n 2    90             4\n 3    90             4\n 4    90             4\n 5    90             5\n 6    90             6\n 7    90             6\n 8    90             7\n 9    90             7\n10    90             9\n# … with 48,832 more rows\n\nFrequencias com dplyr::count()\n\nOBS: vamos ver muito essa função quando falarmos de group_by()\n\n\n\nadult_clean %>% \n  count(age, income, sort = TRUE)\n\n# A tibble: 142 × 3\n     age income     n\n   <int> <fct>  <int>\n 1    23 <=50K   1307\n 2    24 <=50K   1162\n 3    22 <=50K   1161\n 4    25 <=50K   1119\n 5    27 <=50K   1117\n 6    20 <=50K   1112\n 7    28 <=50K   1101\n 8    21 <=50K   1090\n 9    26 <=50K   1068\n10    19 <=50K   1050\n# … with 132 more rows\n\nManipular Variáveis – dplyr::mutate()\n\nOdeio potência de 10\n\nuse options(scipen = 999, digits = 2)\n\n\noptions(scipen = 999, digits = 2)\ncountries <- countries %>% clean_names()\n\ncountries %>% \n  mutate(\n    log_pop = log(population),\n    area_sq_km = area_sq_mi * 2.5899985,\n    pop_density_per_sq_km = population / area_sq_km)\n\n# A tibble: 227 × 23\n   country      region popul…¹ area_…² pop_d…³ coast…⁴ net_m…⁵ infan…⁶\n   <chr>        <chr>    <int>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 Afghanistan  ASIA …  3.11e7  647500    48      0      23.1   163.  \n 2 Albania      EASTE…  3.58e6   28748   125.     1.26   -4.93   21.5 \n 3 Algeria      NORTH…  3.29e7 2381740    13.8    0.04   -0.39   31   \n 4 American Sa… OCEAN…  5.78e4     199   290.    58.3   -20.7     9.27\n 5 Andorra      WESTE…  7.12e4     468   152.     0       6.6     4.05\n 6 Angola       SUB-S…  1.21e7 1246700     9.7    0.13    0     191.  \n 7 Anguilla     LATIN…  1.35e4     102   132.    59.8    10.8    21.0 \n 8 Antigua & B… LATIN…  6.91e4     443   156     34.5    -6.15   19.5 \n 9 Argentina    LATIN…  3.99e7 2766890    14.4    0.18    0.61   15.2 \n10 Armenia      C.W. …  2.98e6   29800    99.9    0      -6.47   23.3 \n# … with 217 more rows, 15 more variables: gdp_per_capita <dbl>,\n#   literacy_percent <dbl>, phones_per_1000 <dbl>,\n#   arable_percent <dbl>, crops_percent <dbl>, other_percent <dbl>,\n#   climate <dbl>, birthrate <dbl>, deathrate <dbl>,\n#   agriculture <dbl>, industry <dbl>, service <dbl>, log_pop <dbl>,\n#   area_sq_km <dbl>, pop_density_per_sq_km <dbl>, and abbreviated\n#   variable names ¹​population, ²​area_sq_mi, …\n\nO mutate ele altera variáveis in-place ou adiciona novas variáveis preservando as existentes. Mas temos também o transmute adiciona novas variáveis e dropa todas as demais.\n\n\ncountries %>% \n  transmute(\n    log_pop = log(population),\n    area_sq_km = area_sq_mi * 2.5899985,\n    pop_density_per_sq_km = population / area_sq_km)\n\n# A tibble: 227 × 3\n   log_pop area_sq_km pop_density_per_sq_km\n     <dbl>      <dbl>                 <dbl>\n 1   17.3    1677024.                 18.5 \n 2   15.1      74457.                 48.1 \n 3   17.3    6168703.                  5.34\n 4   11.0        515.                112.  \n 5   11.2       1212.                 58.7 \n 6   16.3    3228951.                  3.76\n 7    9.51       264.                 51.0 \n 8   11.1       1147.                 60.2 \n 9   17.5    7166241.                  5.57\n10   14.9      77182.                 38.6 \n# … with 217 more rows\n\nQuase todos os verbos (como vocês viram lá em cima) do {dplyr} tem os sufixos _if, _all e _at. Por exemplo:\n\n\ncovid %>% \n  mutate_if(is.character, as.factor)\n\n# A tibble: 236,017 × 7\n   ObservationDate Province/S…¹ Count…² Last …³ Confi…⁴ Deaths Recov…⁵\n   <date>          <fct>        <fct>   <fct>     <dbl>  <dbl>   <dbl>\n 1 2020-01-22      Anhui        Mainla… 1/22/2…       1      0       0\n 2 2020-01-22      Beijing      Mainla… 1/22/2…      14      0       0\n 3 2020-01-22      Chongqing    Mainla… 1/22/2…       6      0       0\n 4 2020-01-22      Fujian       Mainla… 1/22/2…       1      0       0\n 5 2020-01-22      Gansu        Mainla… 1/22/2…       0      0       0\n 6 2020-01-22      Guangdong    Mainla… 1/22/2…      26      0       0\n 7 2020-01-22      Guangxi      Mainla… 1/22/2…       2      0       0\n 8 2020-01-22      Guizhou      Mainla… 1/22/2…       1      0       0\n 9 2020-01-22      Hainan       Mainla… 1/22/2…       4      0       0\n10 2020-01-22      Hebei        Mainla… 1/22/2…       1      0       0\n# … with 236,007 more rows, and abbreviated variable names\n#   ¹​`Province/State`, ²​`Country/Region`, ³​`Last Update`, ⁴​Confirmed,\n#   ⁵​Recovered\n\ndplyr::if_else e dplyr::case_when\nUsamos o if_else quando queremos fazer um teste booleano e gerar um valor caso o teste seja verdadeiro e outro valor caso o teste seja falso. Basicamente um if ... else ...:\n\n\nadult_clean %>% \n  mutate(\n    race_black = if_else(race == \"Black\", 1L, 0L)\n  ) %>% \n  select(starts_with(\"race\"))\n\n# A tibble: 48,842 × 2\n   race  race_black\n   <fct>      <int>\n 1 Black          1\n 2 White          0\n 3 White          0\n 4 Black          1\n 5 White          0\n 6 White          0\n 7 Black          1\n 8 White          0\n 9 White          0\n10 White          0\n# … with 48,832 more rows\n\nTemos algo um pouco mais flexível, poderoso; porém verboso. Esse é o dplyr::case_when:\n\n\nadult_cat <- adult_clean %>% \n  mutate(\n    marital_status_cat = case_when(\n      marital_status == \"Never-married\" ~ 1L,\n      marital_status == \"Married-civ-spouse\" ~ 2L,\n      marital_status == \"Married-spouse-absent\" ~ 3L,\n      marital_status == \"Married-AF-spouse \" ~ 4L,\n      marital_status == \"Separated\" ~ 5L,\n      marital_status == \"Divorced\" ~ 6L,\n      marital_status == \"Widowed\" ~ 7L,\n      TRUE ~ NA_integer_\n    ),\n    marital_age_group = case_when(\n      marital_status_cat == 1 & age >=30 ~ \"solteirx_convictx\",\n      marital_status_cat == 1 & age <=30 ~ \"solteirx_jovem\",\n      marital_status_cat > 1 & marital_status_cat <= 4 & age >=30 ~ \"adultos_casados\",\n      marital_status_cat > 1 & marital_status_cat <= 4 & age <=30 ~ \"jovens_casados\",\n      TRUE ~ \"divorciados, separados etc\"\n    )\n  ) \n  adult_cat %>% \n    select(starts_with(\"marital\")) %>%\n    count(marital_age_group, sort = TRUE)\n\n# A tibble: 5 × 2\n  marital_age_group              n\n  <chr>                      <int>\n1 adultos_casados            20195\n2 solteirx_jovem             10798\n3 divorciados, separados etc  9718\n4 solteirx_convictx           5319\n5 jovens_casados              2812\n\nAgrupar e Sumarizar Variáveis – dplyr::group_by() e dplyr::summarise()\nAgrupamos dados com o dplyr::group_by() e depois usamos o dplyr::summarise() (também existe na versão inglês americano como dplyr::summarize()`) para computar valores dos grupos. Este tipo de análise é chamada comumente de split-apply-combine.\n\n\nadult_cat %>% \n  group_by(marital_age_group) %>% \n  summarise(\n    n = n(),\n    n_prop = n / nrow(.)) %>% \n  arrange(-n)\n\n# A tibble: 5 × 3\n  marital_age_group              n n_prop\n  <chr>                      <int>  <dbl>\n1 adultos_casados            20195 0.413 \n2 solteirx_jovem             10798 0.221 \n3 divorciados, separados etc  9718 0.199 \n4 solteirx_convictx           5319 0.109 \n5 jovens_casados              2812 0.0576\n\n\n\ncovid %>% \n  janitor::clean_names() %>% \n  group_by(country_region) %>% \n  summarise(\n    n = n(),\n    media_confirmados = mean(confirmed),\n    mediana_confirmados = median(confirmed),\n    media_mortos = mean(deaths),\n    mediana_mortos = median(deaths)\n  ) %>% \n  arrange(-mediana_mortos)\n\n# A tibble: 226 × 6\n   country_region     n media_confirmados mediana_co…¹ media…² media…³\n   <chr>          <int>             <dbl>        <dbl>   <dbl>   <dbl>\n 1 Iran             375           533357.      361150   25526.  20776 \n 2 South Africa     360           564541.      627650   14975.  14206 \n 3 Argentina        362           713468.      413080.  18151.   8558.\n 4 Indonesia        363           334202.      172053   10592.   7343 \n 5 Iraq             371           272190.      215784    6416.   6668 \n 6 Ecuador          364           116916.      111680    8028.   6546 \n 7 Turkey           354           717519.      275749    9999.   6538.\n 8 Bolivia          354            98196.      119180.   5184.   5316.\n 9 Egypt            380            80259.       97192.   4399.   5237 \n10 Bangladesh       357           279329.      317528    4023.   4351 \n# … with 216 more rows, and abbreviated variable names\n#   ¹​mediana_confirmados, ²​media_mortos, ³​mediana_mortos\n\nEu posso agrupar por vários grupos por exemplo:\n\n\nlibrary(tidyr)\ncovid %>% \n  janitor::clean_names() %>% \n  group_by(country_region, province_state) %>% \n  drop_na() %>% \n  count(wt = deaths, sort = TRUE)\n\n# A tibble: 760 × 3\n# Groups:   country_region, province_state\n#   [760]\n   country_region province_state        n\n   <chr>          <chr>             <dbl>\n 1 UK             England        13897698\n 2 US             New York       10888511\n 3 Brazil         Sao Paulo       9651617\n 4 India          Maharashtra     9117030\n 5 Italy          Lombardia       5743485\n 6 US             California      5358608\n 7 Brazil         Rio de Janeiro  5335936\n 8 US             Texas           5072817\n 9 US             New Jersey      5054435\n10 US             Florida         4153905\n# … with 750 more rows\n\nLembra que todos os verbos do {dplyr} tem o sufixo _all, _if e _at?\n\n\ncovid %>% \n  summarise_if(is.numeric, median)\n\n# A tibble: 1 × 3\n  Confirmed Deaths Recovered\n      <dbl>  <dbl>     <dbl>\n1      6695    127      1224\n\nNão sei o futuro das coisas _if, _at e _all, pois o lifecycle está em superseded. Então se vocês quiserem um código robusto ao tempo usem o across:\n\n\ncovid %>% \n  summarise(across(where(is.numeric), ~median(.x, na.rm = TRUE)))\n\n# A tibble: 1 × 3\n  Confirmed Deaths Recovered\n      <dbl>  <dbl>     <dbl>\n1      6695    127      1224\n\n\nQual a diferença de grouped_df e tibble?\n\nSe você estiver no mundo do {tidyverse} nenhuma, mas se você for dar um pipe %>% de um grouped_df em algo que não é do {tidyverse} e que somente aceita tibbles e data.frames você vai receber um erro. Nesses casos antes de “pipar” %>% você faz um ungroup():\n\n\nadult_clean %>% \n  group_by(gender) %>% \n  class() %>% \n  print\n\n[1] \"grouped_df\" \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nadult_clean %>% \n  group_by(gender) %>% \n  ungroup() %>% # <----- \"desgrupando\"\n  class() %>% \n  print\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\ncovid <- covid %>% janitor::clean_names()\ncountries <- countries %>% janitor::clean_names()\n\n\nJoins com dplyr::join*\nVamos para a cereja do bolo que é os famosos joins. {dplyr} tem os seguintes joins:\ninner_join(): inclui todas as observações de x e y.\nleft_join(): inclui todas as observações de x.\nright_join(): inclui todas as observações de y.\nfull_join(): inclui todas as observações de x ou y.\n\nOBS: participação especial do {stringr}\n\n\n\nlibrary(stringr)\n# antes de fazer o join vamos ver se vai dar certo\n227 - sum(countries$country %in% covid$country_region)\n\n[1] 42\n\n\n\ncovid %>%\n  count(country_region, wt = confirmed, sort = TRUE) %>% \n  filter(str_detect(country_region, \"China\"))\n\n# A tibble: 1 × 2\n  country_region        n\n  <chr>             <dbl>\n1 Mainland China 32591323\n\n\n\ncountries %>%\n  filter(str_detect(country, \"China\"))\n\n# A tibble: 1 × 20\n  country region       popul…¹ area_…² pop_d…³ coast…⁴ net_m…⁵ infan…⁶\n  <chr>   <chr>          <int>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 China   ASIA (EX. N…  1.31e9 9596960    137.    0.15    -0.4    24.2\n# … with 12 more variables: gdp_per_capita <dbl>,\n#   literacy_percent <dbl>, phones_per_1000 <dbl>,\n#   arable_percent <dbl>, crops_percent <dbl>, other_percent <dbl>,\n#   climate <dbl>, birthrate <dbl>, deathrate <dbl>,\n#   agriculture <dbl>, industry <dbl>, service <dbl>, and abbreviated\n#   variable names ¹​population, ²​area_sq_mi, ³​pop_density_per_sq_mi,\n#   ⁴​coastline_coast_area_ratio, ⁵​net_migration, …\n\n\n\nlibrary(ggplot2)\ncovid %>% \n  mutate(\n    country_region = str_replace(country_region, \"Mainland China\", \"China\")\n  ) %>% \n  filter(observation_date == max(observation_date)) %>% \n  right_join(countries,\n             by = c(\"country_region\" = \"country\")) %>% \n  mutate(deaths_per_capita = deaths / population) %>% \n  ggplot(aes(x = gdp_per_capita, y = deaths_per_capita)) +\n  geom_point() +\n  geom_smooth(method = lm)\n\n\n\nMais transformações para formato Tidy Data com {tidyr}\nO tidyr tem o famoso drop_na(). Então se vocês forem usar o drop_na() junto com o dplyr não esqueçam do library(tidyr).\n\nOBS: vocês podem importar TODO o {tidyverse} de uma vez só com o library(tidyverse)\n\nEm especial temos as funções pivot_longer() e pivot_wider():\nDataset tidyr::relig_income\nDataset tidyr::billboard\nDataset tidyr::fish_encounters\n\n\nlibrary(tidyr)\nrelig_income %>% \n  pivot_longer(!religion,\n               names_to = \"income\",\n               values_to = \"count\") %>% \n  mutate(across(where(is.character), as.factor)) %>% \n  filter(!str_detect(income, \"Don't know\")) %>% \n  count(religion, income, wt = count, sort = TRUE)\n\n# A tibble: 162 × 3\n   religion         income       n\n   <fct>            <fct>    <dbl>\n 1 Evangelical Prot $50-75k   1486\n 2 Catholic         $50-75k   1116\n 3 Mainline Prot    $50-75k   1107\n 4 Evangelical Prot $20-30k   1064\n 5 Evangelical Prot $30-40k    982\n 6 Catholic         $75-100k   949\n 7 Evangelical Prot $75-100k   949\n 8 Mainline Prot    $75-100k   939\n 9 Evangelical Prot $40-50k    881\n10 Evangelical Prot $10-20k    869\n# … with 152 more rows\n\n\n\nbillboard %>% \n  pivot_longer(\n    cols = starts_with(\"wk\"),\n    names_to = \"week\",\n    values_to = \"rank\",\n    values_drop_na = TRUE\n  ) %>% \n  group_by(artist) %>% \n  summarise(\n    n = n(),\n    median_rank = median(rank)) %>% \n  arrange(-n, median_rank)\n\n# A tibble: 228 × 3\n   artist                  n median_rank\n   <chr>               <int>       <dbl>\n 1 Creed                 104        28.5\n 2 Lonestar               95        38  \n 3 Destiny's Child        92        13  \n 4 N'Sync                 74        12  \n 5 Sisqo                  74        25.5\n 6 3 Doors Down           73        42  \n 7 Jay-Z                  73        45  \n 8 Aguilera, Christina    67        17  \n 9 Hill, Faith            67        28  \n10 Houston, Whitney       67        54  \n# … with 218 more rows\n\n\n\nfish_encounters %>%\n  pivot_wider(\n    names_from = station,\n    values_from = seen,\n    values_fill = 0\n  ) %>% \n  pivot_longer(!fish, names_to = \"station\", values_to = \"seen\")\n\n# A tibble: 209 × 3\n   fish  station  seen\n   <fct> <chr>   <int>\n 1 4842  Release     1\n 2 4842  I80_1       1\n 3 4842  Lisbon      1\n 4 4842  Rstr        1\n 5 4842  Base_TD     1\n 6 4842  BCE         1\n 7 4842  BCW         1\n 8 4842  BCE2        1\n 9 4842  BCW2        1\n10 4842  MAE         1\n# … with 199 more rows\n\nAlém do unnest_wider() e unnest_longer():\nDataset repurrrsive::got_chars\n\n\nlibrary(repurrrsive)\nchars <- tibble(char = got_chars)\nchars %>%\n  unnest_wider(char) %>% \n  select(name, books, tvSeries) %>% \n  pivot_longer(!name, names_to = \"media\") %>% \n  unnest_longer(value) %>% \n  filter(media == \"tvSeries\") %>% \n  extract(value, \"season\", \"(\\\\d{1})\", convert = TRUE)\n\n# A tibble: 102 × 3\n   name             media    season\n   <chr>            <chr>     <int>\n 1 Theon Greyjoy    tvSeries      1\n 2 Theon Greyjoy    tvSeries      2\n 3 Theon Greyjoy    tvSeries      3\n 4 Theon Greyjoy    tvSeries      4\n 5 Theon Greyjoy    tvSeries      5\n 6 Theon Greyjoy    tvSeries      6\n 7 Tyrion Lannister tvSeries      1\n 8 Tyrion Lannister tvSeries      2\n 9 Tyrion Lannister tvSeries      3\n10 Tyrion Lannister tvSeries      4\n# … with 92 more rows\n\nUma outra maneira\n\n\nchars %>%\n  unnest_wider(char) %>% \n  select(name, books, tvSeries) %>% \n  pivot_longer(!name, names_to = \"media\") %>% \n  unnest_longer(value) %>% \n  filter(media == \"tvSeries\") %>% \n  separate(value, into = c(NA, \"season\"), sep = \" \", fill = \"right\")\n\n# A tibble: 102 × 3\n   name             media    season\n   <chr>            <chr>    <chr> \n 1 Theon Greyjoy    tvSeries 1     \n 2 Theon Greyjoy    tvSeries 2     \n 3 Theon Greyjoy    tvSeries 3     \n 4 Theon Greyjoy    tvSeries 4     \n 5 Theon Greyjoy    tvSeries 5     \n 6 Theon Greyjoy    tvSeries 6     \n 7 Tyrion Lannister tvSeries 1     \n 8 Tyrion Lannister tvSeries 2     \n 9 Tyrion Lannister tvSeries 3     \n10 Tyrion Lannister tvSeries 4     \n# … with 92 more rows\n\nExtras\nConverter verbos {dplyr} em SQL com o {dbplyr}\n\n\nlibrary(dplyr, warn.conflicts = FALSE)\n\ncon <- DBI::dbConnect(RSQLite::SQLite(), \":memory:\")\ncopy_to(con, mtcars)\n\nmtcars2 <- tbl(con, \"mtcars\")\n\n\nPosso muito bem converter verbos {dplyr} para SQL (para todos os amantes de SQL)\n\n\nsummary <- mtcars2 %>% \n  group_by(cyl) %>% \n  summarise(mpg = mean(mpg, na.rm = TRUE)) %>% \n  arrange(-mpg)\n\nsummary %>% show_query()\n\n<SQL>\nSELECT `cyl`, AVG(`mpg`) AS `mpg`\nFROM `mtcars`\nGROUP BY `cyl`\nORDER BY -`mpg`\n\nsummary %>% collect()\n\n# A tibble: 3 × 2\n    cyl   mpg\n  <dbl> <dbl>\n1     4  26.7\n2     6  19.7\n3     8  15.1\n\nBig Data com {arrow}\nAmbiente\n\n\nsessionInfo()\n\nR version 4.2.2 (2022-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.1 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n[1] repurrrsive_1.1.0 ggplot2_3.4.1     stringr_1.5.0    \n[4] tidyr_1.3.0       janitor_2.2.0     dplyr_1.1.0      \n[7] readr_2.1.4       magrittr_2.0.3    tibble_3.1.8     \n\nloaded via a namespace (and not attached):\n [1] lubridate_1.9.2  lattice_0.20-45  png_0.1-8       \n [4] assertthat_0.2.1 rprojroot_2.0.3  digest_0.6.31   \n [7] utf8_1.2.3       R6_2.5.1         RSQLite_2.3.0   \n[10] evaluate_0.20    highr_0.10       pillar_1.8.1    \n[13] rlang_1.0.6      rstudioapi_0.14  blob_1.2.3      \n[16] jquerylib_0.1.4  Matrix_1.5-1     rmarkdown_2.20  \n[19] labeling_0.4.2   splines_4.2.2    bit_4.0.5       \n[22] munsell_0.5.0    compiler_4.2.2   xfun_0.37       \n[25] pkgconfig_2.0.3  mgcv_1.8-41      htmltools_0.5.4 \n[28] downlit_0.4.2    tidyselect_1.2.0 bookdown_0.32   \n[31] fansi_1.0.4      dbplyr_2.3.0     crayon_1.5.2    \n[34] tzdb_0.3.0       withr_2.5.0      grid_4.2.2      \n[37] nlme_3.1-160     jsonlite_1.8.4   gtable_0.3.1    \n[40] lifecycle_1.0.3  DBI_1.1.3        scales_1.2.1    \n[43] cli_3.6.0        stringi_1.7.12   vroom_1.6.1     \n[46] cachem_1.0.6     farver_2.1.1     snakecase_0.11.0\n[49] bslib_0.4.2      ellipsis_0.3.2   generics_0.1.3  \n[52] vctrs_0.5.2      distill_1.5      tools_4.2.2     \n[55] bit64_4.0.5      glue_1.6.2       purrr_1.0.1     \n[58] hms_1.1.2        parallel_4.2.2   fastmap_1.1.0   \n[61] yaml_2.3.7       timechange_0.2.0 colorspace_2.1-0\n[64] memoise_2.0.1    knitr_1.42       sass_0.4.5      \n\n\n\n\n",
      "last_modified": "2023-02-27T14:11:29+00:00"
    },
    {
      "path": "3-Visualizacao_Dados.html",
      "title": "Visualização de Dados",
      "description": "ggplot2, scales, patchwork, e mais",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 12, 2021",
      "contents": "\n\nContents\nComo usar?\nGeom\nEstéticas com aes()\nAtributos dentro e fora do aes()\n\nRótulos com labs()\nFacetação com facet_wrap()\nCustomização de Temas com theme()\nEscalas com o scale_*_*()\nMais escalas com o {scales}\n“Como é que salva?” ggsave()\nCompor múltiplos gráficos com {patchwork}\nFree Samples\nAmbiente\n\n\n\n\n\nFigure 1: Crie sua Obra-Prima!\n\n\n\n{ggplot2} é um sistema para a criação declarativa de gráficos, baseado na Gramática dos Gráficos–um esquema geral para visualização de dados que divide os gráficos em componentes semânticos, como escalas e camadas. Você fornece os dados, diz ao {ggplot2} como mapear as variáveis para as estéticas, quais primitivos gráficos usar e ele cuida dos detalhes.\nUm livro muito bom sobre visualização de dados é o “Fundamentals of Data Visualizations” de Claus Wilke (Figura 2). Um segredinho, ele foi todo feito em Rmarkdown e ggplot2 #ficaadica.\n\n\n\nFigure 2: Fundamentals of Data Visualization\n\n\n\nComo usar?\nCada gráfico {ggplot2} tem três componentes principais:\ndados (data),\nUm conjunto de mapeamentos estéticos (aesthetics) aes() entre variáveis nos dados e propriedades visuais, e\nPelo menos uma camada (layer) que descreve como renderizar cada observação. As camadas geralmente são criadas com uma função geom_*.\n\n\nlibrary(ggplot2) # `require(ggplot2)` também serve 99.99% usam `library()`\nlibrary(dplyr)\nmpg %>% # igual a isso `ggplot(data = mpg)`\n  ggplot()\n\n\n\n\n\nmpg %>% \n  ggplot(aes(hwy, cty))\n\n\n\n\n\nmpg %>% \n  ggplot(aes(hwy, cty)) + \n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\nOBS: Porque + e não o pipe %>%?\nLembra que eu falei que {ggplot2} veio antes do {tidyverse} e antes do Hadley trabalhar totalmente com opensource na RStudio? Então os geom_*() vieram antes do pipe %>%. Por isso a API adiciona camadas. Então usamos o +.\n\n\nPergunta: Quero interatividade?! E agora?\nResposta: Não tema! Use o {plotly} e seja feliz!\n\n\n\nlibrary(plotly)\np <- mpg %>% \n  ggplot(aes(hwy, cty)) + \n  geom_point() +\n  geom_smooth(method = \"lm\")\nggplotly(p)\n\n\n\nGeom\nTemos vários! VÁRIOS! Vou mostrar alguns mais comuns:\ngeom_point(): gráficos de dispersão.\n\n\nmpg %>% \n  ggplot(aes(cyl)) +\n  geom_point(aes(y = hwy), shape = 3, color = \"steelblue\") +\n  geom_point(aes(y = cty), shape = 1, color = \"red\")\n\n\n\ngeom_smooth(): ajusta uma linha de tendêndia (suavizada ou linear) aos dados e a exibe junto com o seu erro padrão. Muitas vezes usado em conjunto com o geom_point().\n\n\nggplot(mpg, aes(displ, hwy, colour = class)) + \n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\ngeom_boxplot(): diagrama de caixa, o queridinho dos estatísticos (idealizado por John Tukey).\n\n\nmpg %>% \n  ggplot(aes(class, hwy, colour = class)) +\n  geom_boxplot()\n\n\n\ngeom_histogram() e geom_density(): distribuição de variáveis contínuas, intervalares ou ordinais.\n\n\nmpg %>% \n  ggplot(aes(hwy)) +\n  geom_histogram(bins = 30)\n\n\n\n\n\nmpg %>% \n  ggplot(aes(hwy)) +\n  geom_density(fill = \"steelblue\")\n\n\n\ngeom_bar(): distribuição de variáveis discretas, qualitativas, categóricas ou nominais. geom_bar() por padrão conta a frequência das ocorrências mas você pode usar qualquer outra maneira de contagem com o geom_col().\n\n\nmpg %>% \n  ggplot(aes(class)) +\n  geom_bar()\n\n\n\n\n\nlibrary(forcats)\nmpg %>% \n  count(class) %>% \n  mutate(class = as.factor(class),\n         class = fct_reorder(class, n, .desc = TRUE)) %>% \n  ggplot(aes(class, n)) +\n  geom_col()\n\n\n\ngeom_line(): desenha linhas entre as observacões. Muito “abusado”. Tentem usar apenas para séries temporais #ficaadica.\n\n\neconomics %>% \n  ggplot(aes(date, unemploy)) +\n  geom_line()\n\n\n\nEstéticas com aes()\nAlém de x e y temos outros atributos como:\ncolour: cores (cuidado pois as vezes pessoas confundem com fill)\n\n\nmpg %>% \n  ggplot(aes(cyl, hwy, colour = class)) +\n  geom_point()\n\n\n\nfill: preenchimento\n\n\nmpg %>% \n  ggplot(aes(class, fill = manufacturer)) +\n  geom_bar()\n\n\n\nshape: forma\n\n\nmpg %>% \n  ggplot(aes(cyl, cty, shape = class)) +\n  geom_point()\n\n\n\nsize: tamanho\n\n\nmpg %>% \n  ggplot(aes(displ, hwy, colour = class, size = cyl)) + \n  geom_point()\n\n\n\nAtributos dentro e fora do aes()\nVejam abaixo o que vai acontecer!\n\n\nmpg %>% \n  ggplot() +\n  geom_point(aes(displ, hwy, colour =  \"steelblue\"))\n\n\n\n\n\nmpg %>% \n  ggplot() +\n  geom_point(aes(hwy, displ), color = \"steelblue\", size = 5)\n\n\n\nRótulos com labs()\nTeoricamente você precisa somente de ggplot(aes(... )) + geom_*(). Mas à vezes é legal customizar o gráfico com mais informações ou alterar alguma coisa.\n{ggplot2} fornece a função auxiliar labs() para definir o nome para uma ou mais escalas, usando pares nome-valor como x = \"eixo X\" ou fill = \"legenda do preenchimento\". Além disso, você pode adicionar NULL para remover o rótulo:\ntitle: título\nsubtitle: subtítulo\nx: eixo X\ny: eixo Y\ncaption: “rubrica”\n\n\nmpg %>% \n  ggplot(aes(displ, hwy, colour = class, size = cyl)) + \n  geom_point() +\n  labs(\n    title = \"Um gráfico bonito\",\n    subtitle = \"... é aquele que tem subtítulos\",\n    caption = \" ... juntamente com \\\"rubricas\\\"\",\n    x = \"Deslocamento Volumétrico\",\n    y = \"Autonomia em Milhas por Galão\",\n    colour = \"Tipo de Carro\",\n    size = \"QTD Cilindros\"\n  )\n\n\n\n\n\nmpg %>% \n  ggplot(aes(displ, hwy, colour = class, size = cyl)) + \n  geom_point() +\n  labs(\n    title = NULL,\n    subtitle = NULL,\n    caption = NULL,\n    x = NULL,\n    y = NULL,\n    colour = NULL,\n    size = NULL\n  )\n\n\n\nFacetação com facet_wrap()\nOutra técnica para exibir variáveis categóricas adicionais em um gráfico é a facetação. A facetação cria tabelas de gráficos dividindo os dados em subconjuntos e exibindo o mesmo gráfico para cada subconjunto.\nPara facetar um gráfico, você simplesmente adiciona uma especificação de facetamento com facet_wrap(), que leva o nome de uma variável precedida por ~.\n\n\nmpg %>% \n  ggplot(aes(displ, hwy, colour = class, size = cyl)) + \n  geom_point() +\n  facet_wrap(~class)\n\n\n\nfacet_wrap() tem alguns argumentos interessentes:\nnrow ou ncol\nscales controla os eixos x e y\nlabeller controla o “subtítulo” da “faceta”\n\n\nmpg %>% \n  ggplot(aes(displ, hwy, colour = class, size = cyl)) + \n  geom_point() +\n  facet_wrap(~class,\n             ncol = 2,               # mutuamente exclusivo de `nrow`\n             scales = \"free\",        # cada faceta tem seu eixo x e y\n             labeller = \"label_both\" # traz o label da \"facet\" junto com o valor das classes da faceta\n             )\n\n\n\nVocê pode colocar mais facets. Quando você tem mais variáveis o labeller = \"label_value\" funciona muito bem.\n\n\nmpg %>% \n  ggplot(aes(displ, hwy, colour = class, size = cyl)) + \n  geom_point() +\n  facet_wrap(~class + cyl,\n             labeller = \"label_both\")\n\n\n\nCustomização de Temas com theme()\nO sistema de temas é composto por quatro componentes principais:\nOs elementos do tema especificam os elementos que não são de dados que você pode controlar. Por exemplo, o elemento plot.title controla a aparência do título do gráfico; axis.ticks.x, os ticks no eixo x; legend.key.height, a altura das chaves na legenda.\n\n\nmpg %>% \n  ggplot(aes(displ, hwy, colour = class, size = cyl)) + \n  geom_point() +\n  labs(title = \"Algum título que eu vou querer em Comic Sans\") +\n  facet_wrap(~class + cyl,\n             labeller = \"label_both\") +\n  theme(text = element_text(size = 8),\n        plot.title = element_text(family = \"Comic Sans MS\"),\n        axis.ticks.x = element_line(colour = \"purple\",\n                                    arrow = arrow(\n                                      length = unit(\n                                        1, \"mm\"))))\n\n\n\nCada elemento está associado a uma função de elemento, que descreve as propriedades visuais do elemento. Por exemplo, element_text () define o tamanho da fonte, a cor e a face dos elementos de texto como plot.title.\nA função theme () que permite substituir os elementos do tema padrão chamando funções de elemento, como theme(plot.title = element_text (color = \"red\"))\nTemas completos, como theme_grey(), para definir todos os elementos do tema para valores projetados para trabalhar de maneira harmônica.\n\n\nmpg %>% \n  ggplot(aes(displ, hwy, colour = class, size = cyl)) + \n  geom_point() +\n  theme_classic() # gosto bastante\n\n\n\nEscalas com o scale_*_*()\nAs escalas controlam os detalhes de como os valores dos dados são convertidos em propriedades visuais. Temos várias, veja a documentação. Mas vou destacar algumas que uso bastante:\nscale_y_log10(): põe o eixo y numa escala logarítima (parece que isso tá na moda com o COVID).\n\n\neconomics %>% \n  ggplot(aes(date, unemploy)) +\n  geom_line() +\n  scale_y_log10()\n\n\n\nscale_fill_brewer() e scale_colour_brewer(): usa as escalas de cores do Color Brewer 2.0.\n\n\nmpg %>% \nggplot(aes(displ, hwy, colour = class)) + \n  geom_point(alpha = 0.5) +\n  scale_color_brewer(palette = \"Set1\")\n\n\n\nscale_fill_viridis_c() e scale_colour_viridis_c(): usa as escalas de cores opensource do Matplotlib\n\n\nmpg %>% \nggplot(aes(displ, hwy, colour = as.factor(cyl))) + \n  geom_point() +\n  scale_colour_viridis_d(option = \"E\") # cividis que é inclusivo de quem tem \"dificuldades\" de cores\n\n\n\nVamos arrumar o gráfico anterior:\n\n\nmpg %>% \nggplot(aes(displ, hwy, colour = class, size = cyl)) + \n  geom_point(alpha = 0.5) +\n  scale_size(range = c(1, 3))\n\n\n\nMais escalas com o {scales}\nO pacote {scales} fornece a infraestrutura de escala interna usada pelo {ggplot2} e fornece ferramentas para substituir os valores padrões de breaks, labels, transformations etc.\nlabel_percent(): converte os rótulos de um eixo para percentuais.\n\n\neconomics %>%\n  ggplot(aes(date, unemploy / pop)) +\n  geom_line() +\n  scale_y_continuous(labels = scales::label_percent(accuracy = 0.01, decimal.mark = \",\")) +\n  labs(y = \"% de Desempregados da Pop Total\")\n\n\n\nlabel_scientific(): converte os rótulos de um eixo para notação científica (1e05, 1.5e-02 etc.).\nlabel_dollar(): converte os rótulos de um eixo para valores de moeda (U$, R$ etc.)\n\n\neconomics %>% \n  ggplot(aes(date, pce)) +\n  geom_line() +\n  scale_y_continuous(\n    labels = scales::label_dollar(prefix = \"R$ \",\n                                  suffix = \" bi\",\n                                  decimal.mark = \".\")\n  )\n\n\n\n“Como é que salva?” ggsave()\nSó usar o ggsave(dpi = 300)\nCompor múltiplos gráficos com {patchwork}\nO pacote {patchwork} tem como objetivo tornar ridiculamente simples combinar gráficos {ggplot2} em um mesmo gráfico.\nÉ apenas usando operadores aritméticos e relacionais já conhecidos como se fosse uma álgebra de gráficos: (), +, /, | etc.\n\n\nlibrary(patchwork)\np1 <- ggplot(mtcars) + geom_point(aes(mpg, disp))\np2 <- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))\np3 <- ggplot(mtcars) + geom_smooth(aes(disp, qsec))\np4 <- ggplot(mtcars) + geom_bar(aes(carb))\n\n(p1 | p2 | p4) / p3 +\n  plot_annotation(title = \"Quatro gráficos legais\",\n                  tag_levels = \"I\", tag_prefix = \"Fig. \") +\n  plot_layout(nrow = 2, widths = c(1, 3),\n              heights = c(2, 1))\n\n\n\nFree Samples\nVocês já sabem tudo o que é necessário para fazerem visualizações perfeitas no {ggplot2}. Mas tem alguns outros pacotes que valhe a pena aprender.\n{ggrepel}: geoms para {ggplot2} para repelir rótulos de texto sobrepostos.\n\n\nlibrary(ggrepel)\nggplot(mtcars, aes(wt, mpg, label = rownames(mtcars))) +\n  geom_label_repel() +\n  geom_point(color = 'red') +\n  theme_classic(base_size = 12)\n\n\n\nDá para fazer uma gambiarra\n\n\nlibrary(stringr)\nggplot(mtcars, aes(wt, mpg, label = if_else(str_detect(rownames(mtcars), \"Merc\"), rownames(mtcars), NA_character_))) +\n  geom_text_repel() +\n  geom_point(color = 'red') +\n  theme_classic(base_size = 12)\n\n\n\n{gghighlight}: destacar geoms no {ggplot2}.\n\n\nset.seed(2)\nd <- purrr::map_dfr(\n  letters,\n  ~ tibble::tibble(\n      idx = 1:400,\n      value = cumsum(runif(400, -1, 1)),\n      type = .,\n      flag = sample(c(TRUE, FALSE), size = 400, replace = TRUE)\n    )\n)\nd %>%\n  ggplot(aes(idx, value, colour = type)) +\n  geom_line()\n\n\n\nEu posso filtrar?\n\n\nd %>%\n  filter(type %in% c(\"g\", \"s\")) %>% \n  ggplot(aes(idx, value, colour = type)) +\n  geom_line()\n\n\n\nA solução é usar o {gghighlight}:\n\n\nlibrary(gghighlight)\nd %>%\n  ggplot(aes(idx, value, colour = type)) +\n  geom_line() +\n  gghighlight(max(abs(value)) >= 20)\n\n\n\n{ggExtra}: histogramas marginais em gráficos de dispersão.\n\n\nlibrary(ggExtra)\nplot <- mpg %>% \n  ggplot(aes(hwy, cty)) +\n  geom_point(colour = \"steelblue\") \nggMarginal(plot)\n\n\n\n{ggridges}: um dos meus preferidos! Gráficos de densidade múltiplos.\n\n\nlibrary(ggridges)\ndiamonds %>% \n  ggplot(aes(price, cut, fill = as.factor(cut))) +\n  geom_density_ridges() +\n  scale_x_continuous(labels = scales::label_dollar()) +\n  scale_fill_brewer(palette = \"Set1\")\n\n\n\nAmbiente\n\n\nsessionInfo()\n\nR version 4.2.2 (2022-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.1 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n [1] ggridges_0.5.4    ggExtra_0.10.0    gghighlight_0.4.0\n [4] ggrepel_0.9.3     patchwork_1.1.2   forcats_1.0.0    \n [7] plotly_4.10.1     repurrrsive_1.1.0 ggplot2_3.4.1    \n[10] stringr_1.5.0     tidyr_1.3.0       janitor_2.2.0    \n[13] dplyr_1.1.0       readr_2.1.4       magrittr_2.0.3   \n[16] tibble_3.1.8     \n\nloaded via a namespace (and not attached):\n [1] nlme_3.1-160       lubridate_1.9.2    bit64_4.0.5       \n [4] RColorBrewer_1.1-3 httr_1.4.4         rprojroot_2.0.3   \n [7] tools_4.2.2        bslib_0.4.2        utf8_1.2.3        \n[10] R6_2.5.1           DBI_1.1.3          lazyeval_0.2.2    \n[13] mgcv_1.8-41        colorspace_2.1-0   withr_2.5.0       \n[16] tidyselect_1.2.0   downlit_0.4.2      bit_4.0.5         \n[19] compiler_4.2.2     cli_3.6.0          labeling_0.4.2    \n[22] bookdown_0.32      sass_0.4.5         scales_1.2.1      \n[25] digest_0.6.31      rmarkdown_2.20     pkgconfig_2.0.3   \n[28] htmltools_0.5.4    dbplyr_2.3.0       fastmap_1.1.0     \n[31] highr_0.10         htmlwidgets_1.6.1  rlang_1.0.6       \n[34] rstudioapi_0.14    RSQLite_2.3.0      shiny_1.7.4       \n[37] jquerylib_0.1.4    farver_2.1.1       generics_0.1.3    \n[40] jsonlite_1.8.4     crosstalk_1.2.0    vroom_1.6.1       \n[43] distill_1.5        Matrix_1.5-1       Rcpp_1.0.10       \n[46] munsell_0.5.0      fansi_1.0.4        lifecycle_1.0.3   \n[49] stringi_1.7.12     yaml_2.3.7         snakecase_0.11.0  \n[52] grid_4.2.2         blob_1.2.3         promises_1.2.0.1  \n[55] parallel_4.2.2     crayon_1.5.2       miniUI_0.1.1.1    \n[58] lattice_0.20-45    splines_4.2.2      hms_1.1.2         \n[61] knitr_1.42         pillar_1.8.1       glue_1.6.2        \n[64] evaluate_0.20      data.table_1.14.8  png_0.1-8         \n[67] vctrs_0.5.2        tzdb_0.3.0         httpuv_1.6.9      \n[70] gtable_0.3.1       purrr_1.0.1        assertthat_0.2.1  \n[73] cachem_1.0.6       xfun_0.37          mime_0.12         \n[76] xtable_1.8-4       later_1.3.0        viridisLite_0.4.1 \n[79] memoise_2.0.1      timechange_0.2.0   ellipsis_0.3.2    \n\n\n\n\n",
      "last_modified": "2023-02-27T14:11:58+00:00"
    },
    {
      "path": "4-Programacao_Funcional.html",
      "title": "Programação Funcional",
      "description": "purrr e furrr",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 16, 2021",
      "contents": "\n\nContents\nmap_*()\nProfessor, e a ~?\nMOAH POWER! {furrr}\nAmbiente\n\n\n\n\n\nFigure 1: Programação Funcional\n\n\n\n{purrr} tem a seguinte lógica:\nAo invés de:\nfor (i in 1:n) {\n  output[[i]] <- f(input[[i]])\n}\nVocê faz:\nlibrary(purrr)\nlist %>% map(f)    # ou map(list, f)\n\n\nlibrary(purrr)\n1L:10L %>% map(rnorm, 5, 10)\n\n[[1]]\n[1] -0.66\n\n[[2]]\n[1] -2.8  9.6\n\n[[3]]\n[1]  0.47 -6.42 12.58\n\n[[4]]\n[1] 11.2  4.5  4.8  8.2\n\n[[5]]\n[1] -6.4 20.6 -1.6  5.8  4.3\n\n[[6]]\n[1] -12.3 -22.2   9.5 -15.2  -5.1  30.9\n\n[[7]]\n[1] -5.65 16.55  5.18 13.63 11.00  0.89 15.21\n\n[[8]]\n[1]  -5.0 -10.1  16.0  20.6  -7.1  20.1  21.8   7.4\n\n[[9]]\n[1]  7.39 14.63  7.47  3.57  3.89  6.48 19.70 -1.79  0.67\n\n[[10]]\n [1]   4.0 -11.4   8.0  14.7  15.9  24.0  -4.3  28.1   9.6   4.9\n\nmap() — sempre retorna uma list\nmap_lgl(), map_int(), map_dbl() e map_chr() — retornam um vetor do tipo desejado (conversão implícita)\nmap_dfr() e map_dfc() — retornaram um data.frame concatenando colunas (c) ou linhas (r)\nwalk() — usado para efeitos colaterais (side-effects)\nAlém disso temos o map2* (2 listas de inputs) e o pmap* (lista de vetores de inputs, pode ser um data.frame) para múltiplos inputs.\nmap_*()\nConversão implícita\n\n\n1L:10L %>%\n  map(rnorm) %>%\n  map_dbl(mean) # igual a map_dbl(~mean(.x))\n\n [1] -0.297 -0.167 -0.809 -0.556  1.251 -0.713  0.319 -0.045  0.389\n[10]  0.103\n\nProfessor, e a ~?\nO tio ~ (em inglês é tilde) ele funciona quando você precisa especificar funções e argumentos mais complexos:\n\n\nc(\"meu\", \"microfone\", \"está\", \"aberto\") %>% # vire um vetor de c(\"meuprefixo_meu\", ...)\n  map_chr(~paste0(\"meuprefixo_\", .x))\n\n[1] \"meuprefixo_meu\"       \"meuprefixo_microfone\"\n[3] \"meuprefixo_está\"      \"meuprefixo_aberto\"   \n\n\n\nlibrary(ggplot2)\nc(\"hp\", \"wt\", \"qsec\") %>% \n  map(~mtcars %>% \n        ggplot(aes_string(.x, \"mpg\")) +\n        geom_point() +\n        geom_smooth())\n\n[[1]]\n\n\n[[2]]\n\n\n[[3]]\n\n\nAgora é um bom momento para introduzir o purrr::walk\nwalk() — usado para efeitos colaterais (side-effects)\n\n\nc(\"hp\", \"wt\", \"qsec\") %>% \n  walk(~ {p <- mtcars %>% \n        ggplot(aes_string(.x, \"mpg\")) +\n        geom_point() +\n        geom_smooth()\n      print(p)})\n\n\n\n\n\ny <- c(\"mpg\", \"cyl\", \"gear\")\n\nc(\"hp\", \"wt\", \"qsec\") %>% \n  walk2(y, ~{p <- mtcars %>% \n        ggplot(aes_string(.x, .y)) +\n        geom_point() +\n        geom_smooth()\n      print(p)})\n\n\n\nAgora o purrr::pwalk()\n\n\nx <- c(\"hp\", \"wt\", \"qsec\")\ny <- c(\"mpg\", \"cyl\", \"gear\")\nz <- c(\"vs\", \"am\", \"cyl\")\nlist_v <- list(x, y, z)\n\nlist_v %>% \n  pwalk(~{p <- mtcars %>% \n        ggplot(aes_string(..1, ..2, colour = ..3)) + # e continua ..4 ..5 ..6\n        geom_point() +\n        geom_smooth()\n      print(p)})\n\n\n\nAté dá para “knitar” vários markdowns\nc(\"arquivo1.Rmd\", \"arquivo2.Rmd\", ...) %>%    # ou fs::dir_ls(glob = \"*.Rmd\") lê todo o diretório\n  walk(~knitr::render(.x,\n                      output_format = \"html_document\",\n                      output_dir = \"relatorios/\"))\nMOAH POWER! {furrr}\n{purrr} é single-thread então vamos usar o {furrr}.\nPara usar é muito fácil! Ao invés de:\nmap()\nmap2()\npmap()\nwalk()\nUse:\nfuture_map()\nfuture_map2()\nfuture_pmap()\nfuture_walk()\n\n\nseq_len(8) %>% \n  walk(~{\n    Sys.sleep(1)\n    print(\"Oi\")})\n\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n\nAgora com o {furrr}:\n\n\nlibrary(furrr)\nplan(multisession) # ou coloque no `.Rprofile` `options(Ncpus = parallel::detectCores())` e `options(mc.cores = parallel::detectCores())`\n\n\n\n\nseq_len(8) %>% \n  future_walk(~{\n    Sys.sleep(1)\n    print(\"Oi\")},\n    .progress = TRUE)\n\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n[1] \"Oi\"\n\nSe for mexer com coisas aleatórias é importante usar o argumento:\n* .options = furrr_options(seed = TRUE)\n\n\n1L:10L %>% future_map(rnorm)\n\n[[1]]\n[1] 0.33\n\n[[2]]\n[1] -0.76 -0.37\n\n[[3]]\n[1] -2.06 -1.83  0.85\n\n[[4]]\n[1] -1.306  1.214  0.026 -0.457\n\n[[5]]\n[1]  0.95 -0.61 -0.49 -1.37  0.55\n\n[[6]]\n[1]  1.07  0.53 -0.35  0.18 -0.31 -1.75\n\n[[7]]\n[1] -0.63 -0.40  1.45  1.33 -0.47  0.48 -0.40\n\n[[8]]\n[1] -1.005  1.912  0.479  0.578  0.031  0.059  0.534  0.138\n\n[[9]]\n[1] -0.948  0.081 -0.310  0.133  0.869  1.014 -0.472  0.433  1.420\n\n[[10]]\n [1]  0.829  2.082 -0.335 -0.657  0.096 -0.346  0.605 -1.011 -0.050\n[10] -0.423\n\n\n\n1L:10L %>%\n  future_map(rnorm,\n             .options = furrr_options(seed = TRUE))\n\n[[1]]\n[1] 0.32\n\n[[2]]\n[1]  0.26 -2.68\n\n[[3]]\n[1] 0.16 0.43 0.91\n\n[[4]]\n[1]  0.30 -1.11 -2.85  0.42\n\n[[5]]\n[1]  0.32 -0.59 -0.98 -0.58 -0.52\n\n[[6]]\n[1] -0.627  0.830  0.367  0.122  1.210  0.091\n\n[[7]]\n[1] -0.079 -1.188  0.757  1.256  1.521  0.124 -1.445\n\n[[8]]\n[1] -0.085 -0.036 -1.797  0.366  0.054 -2.345 -0.218 -0.141\n\n[[9]]\n[1] -0.27 -0.42  1.55 -0.39 -0.53 -0.65 -0.85  0.45 -1.15\n\n[[10]]\n [1]  0.166  0.084  3.082 -0.108  0.362 -0.876 -0.067 -0.489 -0.976\n[10]  0.712\n\nAmbiente\n\n\nsessionInfo()\n\nR version 4.2.2 (2022-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.1 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n [1] furrr_0.3.1       future_1.31.0     purrr_1.0.1      \n [4] ggridges_0.5.4    ggExtra_0.10.0    gghighlight_0.4.0\n [7] ggrepel_0.9.3     patchwork_1.1.2   forcats_1.0.0    \n[10] plotly_4.10.1     repurrrsive_1.1.0 ggplot2_3.4.1    \n[13] stringr_1.5.0     tidyr_1.3.0       janitor_2.2.0    \n[16] dplyr_1.1.0       readr_2.1.4       magrittr_2.0.3   \n[19] tibble_3.1.8     \n\nloaded via a namespace (and not attached):\n [1] nlme_3.1-160       lubridate_1.9.2    bit64_4.0.5       \n [4] RColorBrewer_1.1-3 httr_1.4.4         rprojroot_2.0.3   \n [7] tools_4.2.2        bslib_0.4.2        utf8_1.2.3        \n[10] R6_2.5.1           DBI_1.1.3          lazyeval_0.2.2    \n[13] mgcv_1.8-41        colorspace_2.1-0   withr_2.5.0       \n[16] tidyselect_1.2.0   downlit_0.4.2      bit_4.0.5         \n[19] compiler_4.2.2     cli_3.6.0          labeling_0.4.2    \n[22] bookdown_0.32      sass_0.4.5         scales_1.2.1      \n[25] digest_0.6.31      rmarkdown_2.20     pkgconfig_2.0.3   \n[28] htmltools_0.5.4    parallelly_1.34.0  dbplyr_2.3.0      \n[31] fastmap_1.1.0      highr_0.10         htmlwidgets_1.6.1 \n[34] rlang_1.0.6        rstudioapi_0.14    RSQLite_2.3.0     \n[37] shiny_1.7.4        jquerylib_0.1.4    farver_2.1.1      \n[40] generics_0.1.3     jsonlite_1.8.4     crosstalk_1.2.0   \n[43] vroom_1.6.1        distill_1.5        Matrix_1.5-1      \n[46] Rcpp_1.0.10        munsell_0.5.0      fansi_1.0.4       \n[49] lifecycle_1.0.3    stringi_1.7.12     yaml_2.3.7        \n[52] snakecase_0.11.0   grid_4.2.2         blob_1.2.3        \n[55] listenv_0.9.0      promises_1.2.0.1   parallel_4.2.2    \n[58] crayon_1.5.2       miniUI_0.1.1.1     lattice_0.20-45   \n[61] splines_4.2.2      hms_1.1.2          knitr_1.42        \n[64] pillar_1.8.1       codetools_0.2-18   glue_1.6.2        \n[67] evaluate_0.20      data.table_1.14.8  png_0.1-8         \n[70] vctrs_0.5.2        tzdb_0.3.0         httpuv_1.6.9      \n[73] gtable_0.3.1       assertthat_0.2.1   cachem_1.0.6      \n[76] xfun_0.37          mime_0.12          xtable_1.8-4      \n[79] later_1.3.0        viridisLite_0.4.1  memoise_2.0.1     \n[82] globals_0.16.2     timechange_0.2.0   ellipsis_0.3.2    \n\n\n\n\n",
      "last_modified": "2023-02-27T14:12:17+00:00"
    },
    {
      "path": "5-Regressao.html",
      "title": "Regressão Linear e Regressão Logística",
      "description": "lm e glm",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 19, 2021",
      "contents": "\n\nContents\nRegressão Linear\nInterpretações\nInterpretação Geométrica\nInterpretação Matemática\nExemplo - Score de QI de crianças\n\nRegressão Logística\nExemplo - Propensão a mudar de poço de água contaminado\n\nRegressão de Poisson - Dados de Contagem\nExemplo Poisson - Exterminação de baratas\n\nComo plotar modelos com o {ggeffects}\nAmbiente\n\n\n\n\n\nFigure 1: Stats\n\n\n\nRegressão Linear\nRegressão linear permite com que você use uma ou mais variáveis discretas ou contínuas como variáveis independentes e mensurar o poder de associação com a variável dependente, que deve ser contínua.\nInterpretações\nPara compreender regressão linear podemos usar de três interpretações distintas mas complementares:\nInterpretação Geométrica: Regressão como uma reta.\nInterpretação Matemática: Regressão como otimização.\nInterpretação Estatística: Regressão como poder de associação entre variáveis controlando para diversos outros efeitos.\nInterpretação Geométrica\nImagine que seus dados são pontos que vivem em um espaço multidimensional. A regressão é uma técnica para encontrar a melhor reta1 entre o conjunto de dados levando em conta todas as observações.\nIsto é valido para qualquer espaço multidimensional, até para além de 3-D. Vamos mostrar um exemplo em 2-D da relação entre x e y, mas isto poder ser estendido para a relação x1, x2, … e y.\n\n\n\nFigure 2: Uma relação entre variáveis representada por uma reta de tendência\n\n\n\nVejam que regressão linear usando apenas uma variável dependente e uma variável independente é a mesma coisa que que correlação.\nInterpretação Matemática\nA interpretação matemática é vista como uma otimização: encontrar a melhor reta entre os pontos que minimiza o erro quadrático médio (mean squared error – MSE). Ao escolhermos a melhor reta, devemos escolher a melhor reta que minimiza as distâncias entre os pontos, sendo que podemos errar para mais ou para menos. Para evitarmos que os erros se cancelem, precisamos eliminar o sinal negativo de alguns erros e convertê-los para valores positivos. Para isso, pegamos todas os erros (diferenças entre o valor previsto pela reta e o valor verdadeiro) e elevamos ao quadrado (assim todo número negativo se tornará positivo e todo positivo se manterá positivo). Portanto, a regressão se torna a busca do menor valor de uma função erro (MSE).\n\n\n\nFigure 3: A melhor reta que minimiza a distância dos erros\n\n\n\nInterpretação Estatística\nA regressão linear usando uma única variável independente contínua se torna exatamente uma correlação. Agora quando empregamos mais de uma variável independente, a interpretação da regressão se torna: “O efeito de X em Y mantendo Z fixo”. Isto quer dizer que a regressão linear controla os efeitos das diferentes variáveis independentes ao calcular o efeito de uma certa variável independente. Esta é o que chamamos de interpretação estatística da regressão linear.\nPor exemplo, digamos que você esteja em busca dos fatores que acarretam ataque cardíaco. Você coleta dados de pessoas que quantifiquem as seguintes variáveis: sono, stress, tabagismo, sedentarismo, entre outros… A regressão te permite mensurar o efeito de qualquer uma dessas variáveis na prevalência de ataque cardíaco controlando para outros efeitos. Em outras palavras, é possível mensurar o efeito de stress em ataque cardíaco, mantendo fixo os efeitos de sono, tabagismo, sedentarismo, etc… Isso permite você isolar o efeito de uma variável sem deixar que outras variáveis a influenciem na mensuração da sua relação com a variável dependente (no nosso caso: ataque cardíaco).\nExemplo - Score de QI de crianças\nPara o nosso exemplo, usarei um dataset famoso chamado kidiq que está incluído no diretório datasets/. São dados de uma survey de mulheres adultas norte-americanas e seus respectivos filhos. Datado de 2007 possui 434 observações e 4 variáveis:\nkid_score: QI da criança\nmom_hs: binária (0 ou 1) se a mãe possui diploma de ensino médio\nmom_iq: QI da mãe\nmom_age: idade da mãe\n\n\nlibrary(readr)\nkidiq <- read_csv(\"datasets/kidiq.csv\", col_types = \"_didi\")\n\n\nComo especificar um modelo em R usando a sintaxe de “formula”\nPodemos espeficiar modelos usando a sintaxe de formula:\ny ~ x1 + x2 + ...\n\n\nkidiq_1 <- lm(kid_score ~ mom_iq, data = kidiq)\nsummary(kidiq_1)\n\n\nCall:\nlm(formula = kid_score ~ mom_iq, data = kidiq)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-56.75 -12.07   2.22  11.71  47.69 \n\nCoefficients:\n            Estimate Std. Error t value             Pr(>|t|)    \n(Intercept)  25.7998     5.9174    4.36             0.000016 ***\nmom_iq        0.6100     0.0585   10.42 < 0.0000000000000002 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 18 on 432 degrees of freedom\nMultiple R-squared:  0.201, Adjusted R-squared:  0.199 \nF-statistic:  109 on 1 and 432 DF,  p-value: <0.0000000000000002\n\n\n\nkidiq_2 <- lm(kid_score ~ mom_iq + mom_hs, data = kidiq)\nsummary(kidiq_2)\n\n\nCall:\nlm(formula = kid_score ~ mom_iq + mom_hs, data = kidiq)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n -52.9  -12.7    2.4   11.4   49.5 \n\nCoefficients:\n            Estimate Std. Error t value             Pr(>|t|)    \n(Intercept)  25.7315     5.8752    4.38             0.000015 ***\nmom_iq        0.5639     0.0606    9.31 < 0.0000000000000002 ***\nmom_hs        5.9501     2.2118    2.69               0.0074 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 18 on 431 degrees of freedom\nMultiple R-squared:  0.214, Adjusted R-squared:  0.21 \nF-statistic: 58.7 on 2 and 431 DF,  p-value: <0.0000000000000002\n\n\n\nkidiq_3 <- lm(kid_score ~ mom_iq * mom_hs, data = kidiq)\nsummary(kidiq_3)\n\n\nCall:\nlm(formula = kid_score ~ mom_iq * mom_hs, data = kidiq)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-52.09 -11.33   2.07  11.66  43.88 \n\nCoefficients:\n              Estimate Std. Error t value      Pr(>|t|)    \n(Intercept)    -11.482     13.758   -0.83        0.4044    \nmom_iq           0.969      0.148    6.53 0.00000000018 ***\nmom_hs          51.268     15.338    3.34        0.0009 ***\nmom_iq:mom_hs   -0.484      0.162   -2.99        0.0030 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 18 on 430 degrees of freedom\nMultiple R-squared:  0.23,  Adjusted R-squared:  0.225 \nF-statistic: 42.8 on 3 and 430 DF,  p-value: <0.0000000000000002\n\nSe você quiser plotar modelos de regressão há o pacote {ggeffect}.\nRegressão Logística\nUma regressão logística se comporta exatamente como um modelo linear: faz uma predição simplesmente computando uma soma ponderada das variáveis independentes, mais uma constante. Porém ao invés de retornar um valor contínuo, como a regressão linear, retorna a função logística desse valor.\n\\[\\operatorname{Logística}(x) = \\frac{1}{1 + e^{(-x)}}\\]\nA função logística é uma gambiarra transformação que pega qualquer valor entre menos infinito \\(-\\infty\\) e mais infinito \\(+\\infty\\) e transforma em um valor entre 0 e 1. Veja na figura 4 uma representação gráfica da função logística.\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\ntibble(\n  x = seq(-10, 10, length.out = 100),\n  logit = 1 / (1 + exp(-x))) %>%\n  ggplot(aes(x, logit)) +\n  geom_line()\n\n\n\nFigure 4: Função Logística\n\n\n\nOu seja, a função logística é a candidata ideal para quando precisamos converter algo contínuo sem restrições para algo contínuo restrito entre 0 e 1. Por isso ela é usada quando precisamos que um modelo tenha como variável dependente uma probabilidade (lembrando que qualquer numero real entre 0 e 1 é uma probabilidade válida). No caso de uma variável dependente binária, podemos usar essa probabilidade como a chance da variável dependente tomar valor de 0 ou de 1.\nExemplo - Propensão a mudar de poço de água contaminado\nPara exemplo, usaremos um dataset chamado wells que está incluído no diretório datasets/. É uma survey com 3.200 residentes de uma pequena área de Bangladesh na qual os lençóis freáticos estão contaminados por arsênico. Respondentes com altos níveis de arsênico nos seus poços foram encorajados para trocar a sua fonte de água para uma níveis seguros de arsênico.\nPossui as seguintes variáveis:\nswitch: dependente indicando se o respondente trocou ou não de poço\narsenic: nível de arsênico do poço do respondente\ndist: distância em metros da casa do respondente até o poço seguro mais próximo\nassociation: dummy se os membros da casa do respondente fazem parte de alguma organização da comunidade\neduc: quantidade de anos de educação que o chefe da família respondente possui\n\n\nwells <- read_csv(\"datasets/wells.csv\", col_types = \"iddii\")\n\n\n\n\nwells1 <- glm(switch ~ arsenic + dist + educ + assoc,\n              data = wells,\n              family = binomial)\nsummary(wells1)\n\n\nCall:\nglm(formula = switch ~ arsenic + dist + educ + assoc, family = binomial, \n    data = wells)\n\nDeviance Residuals: \n   Min      1Q  Median      3Q     Max  \n-2.594  -1.198   0.754   1.063   1.674  \n\nCoefficients:\n            Estimate Std. Error z value             Pr(>|z|)    \n(Intercept) -0.15671    0.09960   -1.57                 0.12    \narsenic      0.46702    0.04160   11.23 < 0.0000000000000002 ***\ndist        -0.00896    0.00105   -8.57 < 0.0000000000000002 ***\neduc         0.04245    0.00959    4.43            0.0000095 ***\nassoc       -0.12430    0.07697   -1.61                 0.11    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 4118.1  on 3019  degrees of freedom\nResidual deviance: 3907.8  on 3015  degrees of freedom\nAIC: 3918\n\nNumber of Fisher Scoring iterations: 4\n\nVamos pegar o exp() dos coeficientes:\n\n\nexp(wells1$coefficients)\n\n(Intercept)     arsenic        dist        educ       assoc \n       0.85        1.60        0.99        1.04        0.88 \n\n\n\nlibrary(ggplot2)\nwells %>% \n  ggplot(aes(arsenic)) +\n  geom_histogram()\n\n\n\nRegressão de Poisson - Dados de Contagem\nUma regressão de Poisson se comporta exatamente como um modelo linear: faz uma predição simplesmente computando uma soma ponderada das variáveis independentes \\(\\mathbf{X}\\) pelos coeficientes estimados \\(\\boldsymbol{\\beta}\\), mais uma constante \\(\\alpha\\). Porém ao invés de retornar um valor contínuo \\(y\\), como a regressão linear, retorna o logarítmo natural desse valor \\(\\log(y)\\).\n\\[\n\\log(y)= \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\dots + \\theta_n x_n\n\\]\nque é o mesmo que\n\\[\ny = e^{(\\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \\dots + \\theta_n x_n)}\n\\]\n\\(\\theta\\) - parâmetros do modelo\n\\(\\theta_0\\) - constante\n\\(\\theta_1, \\theta_2, \\dots\\) - coeficientes das variáveis independentes \\(x_1, x_2, \\dots\\)\n\n\\(n\\) - número de variáveis independentes\nA função \\(e^x\\) é chamada de função exponencial. Veja a figura 5 para uma intuição gráfica da função exponencial:\n\n\nggplot(data = tibble(\n  x = seq(0, 10, length.out = 100),\n  y =  exp(x)\n  ),\n  aes(x, y)) +\n  geom_line(size = 2, color = \"steelblue\") +\n  ylab(\"Exponencial(x)\")\n\n\n\nFigure 5: Função Exponencial\n\n\n\nRegressão de Poisson é usada quando a nossa variável dependente só pode tomar valores positivos, geralmente em contextos de dados de contagem.\nExemplo Poisson - Exterminação de baratas\nPara exemplo, usaremos um dataset chamado roaches que está incluído no diretório datasets/. É uma base de dados com 262 observações sobre a eficácia de um sistema de controle de pragas em reduzir o número de baratas (roaches) em apartamentos urbanos.\nPossui as seguintes variáveis:\ny: variável dependente - número de baratas mortas\nroach1: número de baratas antes da dedetização\ntreatment: dummy para indicar se o apartamento foi dedetizado ou não\nsenior: dummy para indicar se há apenas idosos no apartamento\nexposure2: número de dias que as armadilhas de baratas foram usadas\n\n\nroaches <- read_csv(\"datasets/roaches.csv\", col_types = \"idiid\")\n\n\n\n\nroaches1 <- glm(\n  y ~ roach1 + treatment + senior + exposure2,\n  data = roaches,\n  family = poisson\n)\nsummary(roaches1)\n\n\nCall:\nglm(formula = y ~ roach1 + treatment + senior + exposure2, family = poisson, \n    data = roaches)\n\nDeviance Residuals: \n   Min      1Q  Median      3Q     Max  \n-18.35   -5.29   -4.18    0.29   27.67  \n\nCoefficients:\n              Estimate Std. Error z value             Pr(>|z|)    \n(Intercept)  2.9665993  0.0433859   68.38 < 0.0000000000000002 ***\nroach1       0.0065252  0.0000902   72.38 < 0.0000000000000002 ***\ntreatment   -0.5148722  0.0246802  -20.86 < 0.0000000000000002 ***\nsenior      -0.3787607  0.0335552  -11.29 < 0.0000000000000002 ***\nexposure2    0.1620458  0.0362256    4.47            0.0000077 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 16475  on 261  degrees of freedom\nResidual deviance: 11431  on 257  degrees of freedom\nAIC: 12195\n\nNumber of Fisher Scoring iterations: 6\n\nVamos pegar o exp() dos coeficientes:\n\n\nexp(roaches1$coefficients)\n\n(Intercept)      roach1   treatment      senior   exposure2 \n      19.43        1.01        0.60        0.68        1.18 \n\nComo plotar modelos com o {ggeffects}\nPodemos usar o pacote [{ggeffects}](https://strengejacke.github.io/ggeffects/articles/practical_logisticmixedmodel.html) para *plotar* objetoslmeglm`\n\n\nlibrary(ggeffects)\nplot(ggeffect(kidiq_3))\n\n$mom_iq\n\n\n$mom_hs\n\n\n\n\nplot(ggeffect(wells1))\n\n$arsenic\n\n\n$dist\n\n\n$educ\n\n\n$assoc\n\n\n\n\nplot(ggeffect(roaches1))\n\n$roach1\n\n\n$treatment\n\n\n$senior\n\n\n$exposure2\n\n\nAmbiente\n\n\nsessionInfo()\n\nR version 4.2.2 (2022-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.1 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3\nLAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods  \n[7] base     \n\nother attached packages:\n [1] ggeffects_1.1.5   broom_1.0.3       furrr_0.3.1      \n [4] future_1.31.0     purrr_1.0.1       ggridges_0.5.4   \n [7] ggExtra_0.10.0    gghighlight_0.4.0 ggrepel_0.9.3    \n[10] patchwork_1.1.2   forcats_1.0.0     plotly_4.10.1    \n[13] repurrrsive_1.1.0 ggplot2_3.4.1     stringr_1.5.0    \n[16] tidyr_1.3.0       janitor_2.2.0     dplyr_1.1.0      \n[19] readr_2.1.4       magrittr_2.0.3    tibble_3.1.8     \n\nloaded via a namespace (and not attached):\n [1] minqa_1.2.5        colorspace_2.1-0   ellipsis_0.3.2    \n [4] rprojroot_2.0.3    estimability_1.4.1 snakecase_0.11.0  \n [7] rstudioapi_0.14    listenv_0.9.0      farver_2.1.1      \n[10] bit64_4.0.5        fansi_1.0.4        lubridate_1.9.2   \n[13] codetools_0.2-18   splines_4.2.2      downlit_0.4.2     \n[16] cachem_1.0.6       knitr_1.42         effects_4.2-2     \n[19] jsonlite_1.8.4     nloptr_2.0.3       dbplyr_2.3.0      \n[22] png_0.1-8          shiny_1.7.4        compiler_4.2.2    \n[25] httr_1.4.4         backports_1.4.1    assertthat_0.2.1  \n[28] Matrix_1.5-1       fastmap_1.1.0      lazyeval_0.2.2    \n[31] survey_4.1-1       cli_3.6.0          later_1.3.0       \n[34] htmltools_0.5.4    tools_4.2.2        gtable_0.3.1      \n[37] glue_1.6.2         Rcpp_1.0.10        carData_3.0-5     \n[40] jquerylib_0.1.4    vctrs_0.5.2        nlme_3.1-160      \n[43] crosstalk_1.2.0    insight_0.19.0     xfun_0.37         \n[46] globals_0.16.2     lme4_1.1-31        timechange_0.2.0  \n[49] mime_0.12          miniUI_0.1.1.1     lifecycle_1.0.3   \n[52] MASS_7.3-58.1      scales_1.2.1       vroom_1.6.1       \n[55] hms_1.1.2          promises_1.2.0.1   parallel_4.2.2    \n[58] RColorBrewer_1.1-3 yaml_2.3.7         memoise_2.0.1     \n[61] sass_0.4.5         distill_1.5        stringi_1.7.12    \n[64] RSQLite_2.3.0      highr_0.10         boot_1.3-28       \n[67] rlang_1.0.6        pkgconfig_2.0.3    evaluate_0.20     \n[70] lattice_0.20-45    htmlwidgets_1.6.1  labeling_0.4.2    \n[73] bit_4.0.5          tidyselect_1.2.0   parallelly_1.34.0 \n[76] bookdown_0.32      R6_2.5.1           generics_0.1.3    \n[79] DBI_1.1.3          pillar_1.8.1       withr_2.5.0       \n[82] mgcv_1.8-41        survival_3.4-0     nnet_7.3-18       \n[85] crayon_1.5.2       utf8_1.2.3         tzdb_0.3.0        \n[88] rmarkdown_2.20     grid_4.2.2         data.table_1.14.8 \n[91] blob_1.2.3         digest_0.6.31      xtable_1.8-4      \n[94] httpuv_1.6.9       munsell_0.5.0      viridisLite_0.4.1 \n[97] bslib_0.4.2        mitools_2.4       \n\n\ntecnicamente reta aqui se refere um hiperplano que é subespaço de dimensão \\(n-1\\) de um espaço de dimensão \\(n\\). Por exemplo, uma reta é um hiperplano 1-D de uma plano 2-D; um plano 2-D é um hiperplano de um plano 3-D; e assim por diante…↩︎\n",
      "last_modified": "2023-02-27T14:12:22+00:00"
    },
    {
      "path": "certificados_2021.html",
      "author": [],
      "contents": "\n\nContents\nParticipantes Certificados em 2021\n\nParticipantes Certificados em 2021\nAdriane Nascimento Becker\nAlessandra Cristina Guedes Pellini\nAlvaro Antônio da Silva\nCamila Fragoso Ribeiro\nCarolina Ramos Fugimoto\nCaroline Santana Moura\nCleinton Luiz Klochinski\nChristiane Bischof dos Santos\nDaniela Belchior Brito\nDaniela Menezes Garzaro\nDanielle Cruz Paiva\nEduardo Sakalauskas\nElias Souza Noda\nEvan Jhonnes\nFernando Maciel Ramos\nGabriel Freri Lucas\nGustavo Henrique da Silva Fassione\nJaime Bartholomeu Filho\nKambou sie Kevin\nLeandro Santos\nLincoln Sposito\nLorenzo Gottardi\nLúcio Ramos Moura\nLuís Fábio Cavalcanti da Silva\nMarcelo Luiz do Amaral Gonçalves\nMarco Antonio Casadei Teixeira\nMarcos Ferreira de Magalhães\nMarianna Esteves Nascimento\nMariza Candido S\nMicaelle da Paixão Barbosa Scaramai\nNairana Radtke Caneppele\nRodolfo Valentino Fulgencio\nRodrigo Teixeira\nRogerio Homem da Costa\nRogerio Santino Barboza\nSamara de Carvalho Pedro\nSimone Cesar da Silva Vicente\nThiago de Luca Sant’ana Ribeiro\nCamila Fragoso Ribeiro\nMario Augusto Paixão da Silva\n",
      "last_modified": "2023-02-27T14:12:22+00:00"
    },
    {
      "path": "index.html",
      "title": "Ciência de Dados com R e tidyverse",
      "description": "Disciplina de Linguaguem R para Ciência de Dados de Pós-Graduação da UNINOVE",
      "author": [
        {
          "name": "Jose Storopoli",
          "url": "https://scholar.google.com/citations?user=xGU7H1QAAAAJ&hl=en"
        }
      ],
      "date": "April 5, 2021",
      "contents": "\n\nContents\nProfessor\nComo usar esse conteúdo?\nAulas\nComo citar esse conteúdo\nLicença\n\n\n\nO workshop todo foi gravado e disponibilizado no YouTube na playlist abaixo:\n\n\n\n\n\n\n\nFigure 1: Linguagem R\n\n\n\nRStudio: \nDisciplina de Análise de Dados com R para alunos de pós-graduação. O conteúdo é todo baseado no universo do {tidyverse}.\nSerá coberto conteúdos sobre leitura, manipulação e exportação de dados com R. Recomendo o livro R para Data Science (Figura 2) que pode ser encontrado gratuitamente aqui e possui uma versão impressa em português.\n\n\n\nFigure 2: R for Data Science\n\n\n\nProfessor\nProf. Dr. José Eduardo Storopoli - Currículo Lattes - ORCID - https://storopoli.io\njosees@uni9.pro.br\nComo usar esse conteúdo?\nEste conteúdo possui licença livre para uso (CC BY-SA). Caso queira utilizar o conteúdo para um curso ou estudos, por favor colabore nesse repositório quaisquer aprimorações que foram realizadas.\nPara configurar um ambiente local:\nClone o repositório do GitHub: git clone https://github.com/storopoli/Linguagem-R.git\nAcesse o diretório: cd Linguagem-R\nInstale os pacotes necessários: Rscript .binder/install.R\nAulas\nAula 1 - O que é R?: Tipos de Varíaveis, Estrutura de Dados, RStudio e Rmarkdown.\nAulas 2 e 3 — Manipulação de Dados: dplyr, readr, tidyr e stringr.\nAulas 4 e 5 — Visualização de Dados: ggplot2, scales, patchwork, e mais.\nAulas 6 — Programação Funcional: purrr e furrr.\nAula 7 — Regressão Linear e Regressão Logística: lm e glm.\nComo citar esse conteúdo\nPara citar o conteúdo use:\nStoropoli (2021). Linguagem R. Disponível em: https://storopoli.io/Linguagem-R.\nOu em formato BibTeX para LaTeX:\n@misc{storopoli2021linguagemR,\n  author = {Storopoli, Jose},\n  title = {Linguagem R},\n  url = {https://storopoli.io/Linguagem-R},\n  year = {2021}\n}\nLicença\nEste obra está licenciado com uma Licença\nCreative Commons Atribuição-CompartilhaIgual 4.0 Internacional.\n\n\n\n\n",
      "last_modified": "2023-02-27T14:12:22+00:00"
    }
  ],
  "collections": []
}
